var tipuesearch = {"pages":[{"title":" double mach reflection problem ","text":"double mach reflection problem Developer Info toya42","tags":"home","loc":"index.html"},{"title":"grid – double mach reflection problem","text":"subroutine grid() x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない） Arguments None Calls proc~~grid~~CallsGraph proc~grid grid x x proc~grid->x y y proc~grid->y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid~~CalledByGraph proc~grid grid program~main main program~main->proc~grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mesh dlxy Common Blocks common /mesh/ Type Attributes Name Initial real :: x (0:jmax+1,0:kmax+1) real :: y (0:jmax+1,0:kmax+1) common /dlxy/ Type Attributes Name Initial real :: dltx real :: dlty","tags":"","loc":"proc/grid.html"},{"title":"init – double mach reflection problem","text":"subroutine init() x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない） Arguments None Calls proc~~init~~CallsGraph proc~init init x x proc~init->x y y proc~init->y dsign dsign proc~init->dsign pris pris proc~init->pris cons cons proc~init->cons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~init~~CalledByGraph proc~init init program~main main program~main->proc~init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks stt0 stt1 mesh cons pris Common Blocks common /stt0/ Type Attributes Name Initial real :: r0 real :: p0 real :: u0 real :: v0 real :: ru0 real :: rv0 real :: e0 common /stt1/ Type Attributes Name Initial real :: r1 real :: p1 real :: u1 real :: v1 real :: ru1 real :: rv1 real :: e1 common /mesh/ Type Attributes Name Initial real :: x (0:jmax+1,0:kmax+1) real :: y (0:jmax+1,0:kmax+1) common /cons/ Type Attributes Name Initial real :: cons (4,0:jmax+1,0:kmax+1) common /pris/ Type Attributes Name Initial real :: pris (4,0:jmax+1,0:kmax+1)","tags":"","loc":"proc/init.html"},{"title":"outf – double mach reflection problem","text":"subroutine outf() x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない） Arguments None Calls proc~~outf~~CallsGraph proc~outf outf cons cons proc~outf->cons Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~outf~~CalledByGraph proc~outf outf program~main main program~main->proc~outf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks cons time loop Common Blocks common /cons/ Type Attributes Name Initial real :: cons (4,0:jmax+1,0:kmax+1) common /time/ Type Attributes Name Initial real :: tn real :: tt common /loop/ Type Attributes Name Initial integer :: im","tags":"","loc":"proc/outf.html"},{"title":"stbc – double mach reflection problem","text":"subroutine stbc() x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない） Arguments None Calls proc~~stbc~~CallsGraph proc~stbc stbc cons cons proc~stbc->cons dsign dsign proc~stbc->dsign x x proc~stbc->x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~stbc~~CalledByGraph proc~stbc stbc program~main main program~main->proc~stbc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks stt0 stt1 mesh cons time loop Common Blocks common /stt0/ Type Attributes Name Initial real :: r0 real :: p0 real :: u0 real :: v0 real :: ru0 real :: rv0 real :: e0 common /stt1/ Type Attributes Name Initial real :: r1 real :: p1 real :: u1 real :: v1 real :: ru1 real :: rv1 real :: e1 common /mesh/ Type Attributes Name Initial real :: x (0:jmax+1,0:kmax+1) real :: y (0:jmax+1,0:kmax+1) common /cons/ Type Attributes Name Initial real :: cons (4,0:jmax+1,0:kmax+1) common /time/ Type Attributes Name Initial real :: tn real :: tt common /loop/ Type Attributes Name Initial integer :: im","tags":"","loc":"proc/stbc.html"},{"title":"c2p – double mach reflection problem","text":"subroutine c2p() x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない） Arguments None Calls proc~~c2p~~CallsGraph proc~c2p c2p cons cons proc~c2p->cons pris pris proc~c2p->pris Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~c2p~~CalledByGraph proc~c2p c2p program~main main program~main->proc~c2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks cons pris Common Blocks common /cons/ Type Attributes Name Initial real :: cons (4,0:jmax+1,0:kmax+1) common /pris/ Type Attributes Name Initial real :: pris (4,0:jmax+1,0:kmax+1)","tags":"","loc":"proc/c2p.html"},{"title":"intp – double mach reflection problem","text":"subroutine intp() x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない）\n      y Arguments None Calls proc~~intp~~CallsGraph proc~intp intp pris pris proc~intp->pris pyl pyl proc~intp->pyl dsign dsign proc~intp->dsign pxl pxl proc~intp->pxl pxr pxr proc~intp->pxr pyr pyr proc~intp->pyr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~intp~~CalledByGraph proc~intp intp program~main main program~main->proc~intp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks pris sval Common Blocks common /pris/ Type Attributes Name Initial real :: pris (4,0:jmax+1,0:kmax+1) common /sval/ Type Attributes Name Initial real :: pxl (4,0:jmax+1,0:kmax+1) real :: pxr (4,0:jmax+1,0:kmax+1) real :: pyl (4,0:jmax+1,0:kmax+1) real :: pyr (4,0:jmax+1,0:kmax+1)","tags":"","loc":"proc/intp.html"},{"title":"slau – double mach reflection problem","text":"subroutine slau() Arguments None Calls proc~~slau~~CallsGraph proc~slau slau conl conl proc~slau->conl dsign dsign proc~slau->dsign conr conr proc~slau->conr dnflx dnflx proc~slau->dnflx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~slau~~CalledByGraph proc~slau slau proc~iflx iflx proc~iflx->proc~slau program~main main program~main->proc~iflx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks sflr nvec Common Blocks common /sflr/ Type Attributes Name Initial real :: conL (4) real :: conR (4) real :: dnflx (4) common /nvec/ Type Attributes Name Initial real :: dnx real :: dny","tags":"","loc":"proc/slau.html"},{"title":"iflx – double mach reflection problem","text":"subroutine iflx() x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない） Arguments None Calls proc~~iflx~~CallsGraph proc~iflx iflx pxl pxl proc~iflx->pxl proc~slau slau proc~iflx->proc~slau pyl pyl proc~iflx->pyl yflx yflx proc~iflx->yflx conr conr proc~iflx->conr conl conl proc~iflx->conl pxr pxr proc~iflx->pxr xflx xflx proc~iflx->xflx dnflx dnflx proc~iflx->dnflx pyr pyr proc~iflx->pyr proc~slau->conr proc~slau->conl proc~slau->dnflx dsign dsign proc~slau->dsign Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~iflx~~CalledByGraph proc~iflx iflx program~main main program~main->proc~iflx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks sval flux sflr nvec Common Blocks common /sval/ Type Attributes Name Initial real :: pxl (4,0:jmax+1,0:kmax+1) real :: pxr (4,0:jmax+1,0:kmax+1) real :: pyl (4,0:jmax+1,0:kmax+1) real :: pyr (4,0:jmax+1,0:kmax+1) common /flux/ Type Attributes Name Initial real :: xflx (4,jmax,kmax) real :: yflx (4,jmax,kmax) common /sflr/ Type Attributes Name Initial real :: conL (4) real :: conR (4) real :: dnflx (4) common /nvec/ Type Attributes Name Initial real :: dnx real :: dny","tags":"","loc":"proc/iflx.html"},{"title":"intg – double mach reflection problem","text":"subroutine intg() x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない） Arguments None Calls proc~~intg~~CallsGraph proc~intg intg df df proc~intg->df yflx yflx proc~intg->yflx xflx xflx proc~intg->xflx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~intg~~CalledByGraph proc~intg intg program~main main program~main->proc~intg Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks flux cons dflx dlxy Common Blocks common /flux/ Type Attributes Name Initial real :: xflx (4,jmax,kmax) real :: yflx (4,jmax,kmax) common /cons/ Type Attributes Name Initial real :: cons (4,0:jmax+1,0:kmax+1) common /dflx/ Type Attributes Name Initial real :: df (4,jmax,kmax) common /dlxy/ Type Attributes Name Initial real :: dltx real :: dlty","tags":"","loc":"proc/intg.html"},{"title":"main – double mach reflection problem","text":"x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない）\nパラメータ等設定　includeを用いるのは本来好ましくない\n最大反復数\n終了時間 Calls program~~main~~CallsGraph program~main main proc~grid grid program~main->proc~grid proc~c2p c2p program~main->proc~c2p df df program~main->df proc~intg intg program~main->proc~intg cons cons program~main->cons proc~stbc stbc program~main->proc~stbc proc~init init program~main->proc~init proc~outf outf program~main->proc~outf proc~intp intp program~main->proc~intp proc~iflx iflx program~main->proc~iflx x x proc~grid->x y y proc~grid->y proc~c2p->cons pris pris proc~c2p->pris proc~intg->df yflx yflx proc~intg->yflx xflx xflx proc~intg->xflx proc~stbc->cons proc~stbc->x dsign dsign proc~stbc->dsign proc~init->cons proc~init->x proc~init->y proc~init->pris proc~init->dsign proc~outf->cons proc~intp->pris proc~intp->dsign pyl pyl proc~intp->pyl pxl pxl proc~intp->pxl pxr pxr proc~intp->pxr pyr pyr proc~intp->pyr proc~iflx->yflx proc~iflx->pyl proc~iflx->pxl proc~slau slau proc~iflx->proc~slau proc~iflx->xflx proc~iflx->pxr proc~iflx->pyr conr conr proc~iflx->conr conl conl proc~iflx->conl dnflx dnflx proc~iflx->dnflx proc~slau->dsign proc~slau->conr proc~slau->conl proc~slau->dnflx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Common Blocks mesh dlxy cons pris time loop stt0 stt1 flux sval dflx sflr nvec Variables conn Common Blocks common /mesh/ 格子点座標 0とmax+1は便宜上　計算領域は0-max Type Attributes Name Initial real :: x (0:jmax+1,0:kmax+1) real :: y (0:jmax+1,0:kmax+1) common /dlxy/ $ Todo 逆数を定義しておく　intgがちょっと速くなるはず Type Attributes Name Initial real :: dltx real :: dlty common /cons/ 保存量 Type Attributes Name Initial real :: cons (4,0:jmax+1,0:kmax+1) common /pris/ 基本量 Type Attributes Name Initial real :: pris (4,0:jmax+1,0:kmax+1) common /time/ t:現在時間, tt:サブステップの時間 Type Attributes Name Initial real :: tn real :: tt common /loop/ 反復数 Type Attributes Name Initial integer :: im common /stt0/ before shock state Type Attributes Name Initial real :: r0 real :: p0 real :: u0 real :: v0 real :: ru0 real :: rv0 real :: e0 common /stt1/ after shock state Type Attributes Name Initial real :: r1 real :: p1 real :: u1 real :: v1 real :: ru1 real :: rv1 real :: e1 common /flux/ 非粘性流束 Type Attributes Name Initial real :: xflx (4,jmax,kmax) real :: yflx (4,jmax,kmax) common /sval/ 流束評価面に補間された値 l:left, r:right Type Attributes Name Initial real :: pxl (4,0:jmax+1,0:kmax+1) real :: pxr (4,0:jmax+1,0:kmax+1) real :: pyl (4,0:jmax+1,0:kmax+1) real :: pyr (4,0:jmax+1,0:kmax+1) common /dflx/ 時間増分 Type Attributes Name Initial real :: df (4,jmax,kmax) common /sflr/ 非粘性流束評価で用いる値 Type Attributes Name Initial real :: conL (4) real :: conR (4) real :: dnflx (4) common /nvec/ 流束評価面の法線ベクトル Type Attributes Name Initial real :: dnx real :: dny Variables Type Attributes Name Initial double precision :: conn (4,0:jmax+1,0:kmax+1) n stepの保存量の一時的置き場","tags":"","loc":"program/main.html"},{"title":"main.f – double mach reflection problem","text":"Contents Programs main Subroutines grid init outf stbc c2p intp slau iflx intg Source Code main.f Source Code program main !> パラメータ等設定　includeを用いるのは本来好ましくない include \"parameters.f\" !> 最大反復数 parameter ( ilmt = 100 ) !> 終了時間 parameter ( tfin = 0.2d0 ) !> 格子点座標 0とmax+1は便宜上　計算領域は0-max common / mesh / x ( 0 : jmax + 1 , 0 : kmax + 1 ), y ( 0 : jmax + 1 , 0 : kmax + 1 ) !> $ \\Delta x, \\Delta y !!@todo 逆数を定義しておく　intgがちょっと速くなるはず common / dlxy / dltx , dlty !> 保存量　\\rho,\\rho u,\\rho v,e  common / cons / cons ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) !> 基本量　\\rho,u,v,p  common / pris / pris ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) !> t:現在時間, tt:サブステップの時間 common / time / tn , tt !> 反復数 common / loop / im !> before shock state common / stt0 / r0 , p0 , u0 , v0 , ru0 , rv0 , e0 !> after shock state common / stt1 / r1 , p1 , u1 , v1 , ru1 , rv1 , e1 !> 非粘性流束 common / flux / xflx ( 4 , jmax , kmax ), yflx ( 4 , jmax , kmax ) !> 流束評価面に補間された値 l:left, r:right common / sval / pxl ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), pxr ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), & pyl ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), pyr ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) !> 時間増分 common / dflx / df ( 4 , jmax , kmax ) !> 非粘性流束評価で用いる値 common / sflr / conL ( 4 ), conR ( 4 ), dnflx ( 4 ) !> 流束評価面の法線ベクトル common / nvec / dnx , dny !> n stepの保存量の一時的置き場 double precision conn ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) ! pre-process call grid call init im = 0 tn = 0.0d0 df = 0.0d0 conn = cons call outf ! main iteration do im = 1 , ilmt !         runge kutta !         (1) tt = tn + dt call stbc call c2p call intp call iflx call intg do k = 1 , kmax do j = 1 , jmax cons ( 1 , j , k ) = conn ( 1 , j , k ) - dt * df ( 1 , j , k ) cons ( 2 , j , k ) = conn ( 2 , j , k ) - dt * df ( 2 , j , k ) cons ( 3 , j , k ) = conn ( 3 , j , k ) - dt * df ( 3 , j , k ) cons ( 4 , j , k ) = conn ( 4 , j , k ) - dt * df ( 4 , j , k ) end do end do !         (2) tt = tn + 0.5d0 * dt call stbc call c2p call intp call iflx call intg do k = 1 , kmax do j = 1 , jmax cons ( 1 , j , k ) = 0.75 * conn ( 1 , j , k ) & + 0.25 * ( cons ( 1 , j , k ) - dt * df ( 1 , j , k )) cons ( 2 , j , k ) = 0.75 * conn ( 2 , j , k ) & + 0.25 * ( cons ( 2 , j , k ) - dt * df ( 2 , j , k )) cons ( 3 , j , k ) = 0.75 * conn ( 3 , j , k ) & + 0.25 * ( cons ( 3 , j , k ) - dt * df ( 3 , j , k )) cons ( 4 , j , k ) = 0.75 * conn ( 4 , j , k ) & + 0.25 * ( cons ( 4 , j , k ) - dt * df ( 4 , j , k )) end do end do !         (3) tt = tn + dt call stbc call c2p call intp call iflx call intg do k = 1 , kmax do j = 1 , jmax cons ( 1 , j , k ) = onethird * conn ( 1 , j , k ) & + 2.0d0 * onethird * ( cons ( 1 , j , k ) - dt * df ( 1 , j , k )) cons ( 2 , j , k ) = onethird * conn ( 2 , j , k ) & + 2.0d0 * onethird * ( cons ( 2 , j , k ) - dt * df ( 2 , j , k )) cons ( 3 , j , k ) = onethird * conn ( 3 , j , k ) & + 2.0d0 * onethird * ( cons ( 3 , j , k ) - dt * df ( 3 , j , k )) cons ( 4 , j , k ) = onethird * conn ( 4 , j , k ) & + 2.0d0 * onethird * ( cons ( 4 , j , k ) - dt * df ( 4 , j , k )) end do end do conn = cons tn = dt * im !call stbc if ( mod ( im , 100 ) == 0 ) then call stbc call outf endif if ( tn >= tfin ) then call stbc call outf exit end if end do ! post-process end program main subroutine grid include \"parameters.f\" parameter ( xmin = 0.00d0 , xmax = 4.00d0 ) parameter ( ymin = 0.00d0 , ymax = 1.00d0 ) common / mesh / x ( 0 : jmax + 1 , 0 : kmax + 1 ), y ( 0 : jmax + 1 , 0 : kmax + 1 ) common / dlxy / dltx , dlty write ( * , * ) jmax , kmax dltx = ( xmax - xmin ) / ( jmax - 1 ) dlty = ( ymax - ymin ) / ( kmax - 1 ) write ( * , * ) 'dx,dy: ' , dltx , dlty cfl = 1 0.0d0 * dt / dmax1 ( dltx , dlty ) write ( * , * ) 'cfl: ' , cfl do k = 0 , kmax + 1 do j = 0 , jmax + 1 x ( j , k ) = ( j - 1 ) * dltx y ( j , k ) = ( k - 1 ) * dlty end do end do open ( 7 , form = 'unformatted' , file = 'grid.xyz' ) write ( 7 ) jmax , kmax write ( 7 ) (( x ( j , k ), j = 1 , jmax ), k = 1 , kmax ), & (( y ( j , k ), j = 1 , jmax ), k = 1 , kmax ) close ( 7 ) end subroutine grid subroutine init include \"parameters.f\" common / stt0 / r0 , p0 , u0 , v0 , ru0 , rv0 , e0 common / stt1 / r1 , p1 , u1 , v1 , ru1 , rv1 , e1 common / mesh / x ( 0 : jmax + 1 , 0 : kmax + 1 ), y ( 0 : jmax + 1 , 0 : kmax + 1 ) common / cons / cons ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) common / pris / pris ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) r0 = 1.40d0 p0 = 1.00d0 u0 = 0.00d0 v0 = 0.00d0 ru0 = r0 * u0 rv0 = r0 * v0 e0 = p0 * gm1i + 0.5d0 * r0 * ( u0 * u0 + v0 * v0 ) r1 = 8.0d0 p1 = 11 6.5d0 u1 = 4.125d0 * dsqrt ( 3.0d0 ) v1 = - 4.125d0 ru1 = r1 * u1 rv1 = r1 * v1 e1 = p1 * gm1i + 0.5d0 * r1 * ( u1 * u1 + v1 * v1 ) sqr3 = dsqrt ( 3.0d0 ) sqr3x2i = 1.0d0 / ( sqr3 * 2.0d0 ) do k = 0 , kmax + 1 do j = 0 , jmax + 1 xn = x ( j , k ) yn = y ( j , k ) yl = sqr3 * xn - sqr3x2i if ( yn >= yl ) then cons ( 1 , j , k ) = r1 cons ( 2 , j , k ) = ru1 cons ( 3 , j , k ) = rv1 cons ( 4 , j , k ) = e1 pris ( 1 , j , k ) = r1 pris ( 2 , j , k ) = u1 pris ( 3 , j , k ) = v1 pris ( 4 , j , k ) = p1 else cons ( 1 , j , k ) = r0 cons ( 2 , j , k ) = ru0 cons ( 3 , j , k ) = rv0 cons ( 4 , j , k ) = e0 pris ( 1 , j , k ) = r0 pris ( 2 , j , k ) = u0 pris ( 3 , j , k ) = v0 pris ( 4 , j , k ) = p0 end if end do end do !       b.c. ! j=1 (inflow) j = 1 do k = 1 , kmax cons ( 1 , j - 1 , k ) = cons ( 1 , j , k ) cons ( 2 , j - 1 , k ) = cons ( 2 , j , k ) cons ( 3 , j - 1 , k ) = cons ( 3 , j , k ) cons ( 4 , j - 1 , k ) = cons ( 4 , j , k ) end do ! k = 1 onesix = onethird * 0.5d0 do j = 1 , jmax if ( x ( j , k ) > onesix ) then vl1 = dsqrt ( pris ( 2 , j , k + 1 ) * pris ( 2 , j , k + 1 ) & + pris ( 3 , j , k + 1 ) * pris ( 3 , j , k + 1 )) vl0 = dsign ( vl1 , cons ( 2 , j , k )) rho = cons ( 1 , j , k + 1 ) cons ( 1 , j , k ) = rho cons ( 2 , j , k ) = rho * vl0 cons ( 3 , j , k ) = 0.0d0 cons ( 4 , j , k ) = cons ( 4 , j , k + 1 ) cons ( 1 , j , k - 1 ) = rho cons ( 2 , j , k - 1 ) = cons ( 2 , j , k + 1 ) cons ( 3 , j , k - 1 ) =- cons ( 3 , j , k + 1 ) cons ( 4 , j , k - 1 ) = cons ( 4 , j , k + 1 ) end if end do end subroutine init subroutine outf include \"parameters.f\" common / cons / cons ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) common / time / tn , tt common / loop / im character ( len = 50 ) fnam write ( fnam , '(\"flowfield_\",i5.5,\".q\")' ), im open ( 8 , form = 'unformatted' , file = fnam ) write ( 8 ) jmax , kmax write ( 8 ) 1 0.0d0 , 0.0d0 , 1.0d15 , tn write ( 8 ) ((( cons ( n , j , k ), j = 1 , jmax ), k = 1 , kmax ), n = 1 , 4 ) close ( 8 ) write ( * , * ) 'output' , tn , im end subroutine outf subroutine stbc include \"parameters.f\" common / stt0 / r0 , p0 , u0 , v0 , ru0 , rv0 , e0 common / stt1 / r1 , p1 , u1 , v1 , ru1 , rv1 , e1 common / mesh / x ( 0 : jmax + 1 , 0 : kmax + 1 ), y ( 0 : jmax + 1 , 0 : kmax + 1 ) common / cons / cons ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) common / time / tn , tt common / loop / im ! j=jmax (subsonic outflow) j = jmax do k = 1 , kmax cons ( 1 , j , k ) = cons ( 1 , j - 1 , k ) cons ( 2 , j , k ) = cons ( 2 , j - 1 , k ) cons ( 3 , j , k ) = cons ( 3 , j - 1 , k ) dke = 0.5d0 * ( cons ( 2 , j , k ) ** 2 + cons ( 3 , j , k ) ** 2 ) / cons ( 1 , j , k ) pout = gmm1 * ( cons ( 4 , j - 1 , k ) - dke ) cons ( 4 , j , k ) = gm1i * pout + dke cons ( 1 , j + 1 , k ) = cons ( 1 , j , k ) cons ( 2 , j + 1 , k ) = cons ( 2 , j , k ) cons ( 3 , j + 1 , k ) = cons ( 3 , j , k ) cons ( 4 , j + 1 , k ) = cons ( 4 , j , k ) end do ! k=kmax (pre/post shock state) sqrt3 = dsqrt ( 3.0d0 ) xshock = tt * 2 0.0d0 / sqrt3 + 0.5d0 * onethird + 1.0d0 / sqrt3 k = kmax do j = 1 , jmax if ( x ( j , k ) <= xshock ) then cons ( 1 , j , k ) = r1 cons ( 2 , j , k ) = ru1 cons ( 3 , j , k ) = rv1 cons ( 4 , j , k ) = e1 cons ( 1 , j , k + 1 ) = cons ( 1 , j , k ) cons ( 2 , j , k + 1 ) = cons ( 2 , j , k ) cons ( 3 , j , k + 1 ) = cons ( 3 , j , k ) cons ( 4 , j , k + 1 ) = cons ( 4 , j , k ) else cons ( 1 , j , k ) = r0 cons ( 2 , j , k ) = ru0 cons ( 3 , j , k ) = rv0 cons ( 4 , j , k ) = e0 cons ( 1 , j , k + 1 ) = cons ( 1 , j , k ) cons ( 2 , j , k + 1 ) = cons ( 2 , j , k ) cons ( 3 , j , k + 1 ) = cons ( 3 , j , k ) cons ( 4 , j , k + 1 ) = cons ( 4 , j , k ) end if end do k = 1 do j = 1 , jmax if ( x ( j , k ) > 0.5d0 * onethird ) then vl1 = dsqrt ( cons ( 2 , j , k + 1 ) * cons ( 2 , j , k + 1 ) & + cons ( 3 , j , k + 1 ) * cons ( 3 , j , k + 1 )) / cons ( 1 , j , k + 1 ) vl0 = dsign ( vl1 , cons ( 2 , j , k )) rho = cons ( 1 , j , k + 1 ) cons ( 1 , j , k ) = rho cons ( 2 , j , k ) = rho * vl0 cons ( 3 , j , k ) = 0.0d0 cons ( 4 , j , k ) = cons ( 4 , j , k + 1 ) cons ( 1 , j , k - 1 ) = rho cons ( 2 , j , k - 1 ) = cons ( 2 , j , k + 1 ) cons ( 3 , j , k - 1 ) =- cons ( 3 , j , k + 1 ) cons ( 4 , j , k - 1 ) = cons ( 4 , j , k + 1 ) end if end do end subroutine stbc subroutine c2p include \"parameters.f\" common / cons / cons ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) common / pris / pris ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) do k = 0 , kmax + 1 do j = 0 , jmax + 1 rho = cons ( 1 , j , k ) rhoi = 1.0d0 / rho u = cons ( 2 , j , k ) * rhoi v = cons ( 3 , j , k ) * rhoi p = gmm1 * ( cons ( 4 , j , k ) - 0.5d0 * rho * ( u * u + v * v )) pris ( 1 , j , k ) = rho pris ( 2 , j , k ) = u pris ( 3 , j , k ) = v pris ( 4 , j , k ) = p end do end do end subroutine c2p subroutine intp include \"parameters.f\" common / pris / pris ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) common / sval / pxl ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), pxr ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), & pyl ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), pyr ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) parameter ( eps = 1.0d0 , dkpa = onethird ) parameter ( b = ( 3.0d0 - dkpa ) / ( 1.0d0 - dkpa )) ! 1st order !       x !        do k=2,kmax-1 !          do j=1,jmax-1 !            pxl(1,j,k) = pris(1,j,k) !            pxl(2,j,k) = pris(2,j,k) !            pxl(3,j,k) = pris(3,j,k) !            pxl(4,j,k) = pris(4,j,k) !            pxr(1,j,k) = pris(1,j+1,k) !            pxr(2,j,k) = pris(2,j+1,k) !            pxr(3,j,k) = pris(3,j+1,k) !            pxr(4,j,k) = pris(4,j+1,k) !          end do !        end do !!       y !        do j=2,jmax-1 !          do k=1,kmax-1 !            pyl(1,j,k) = pris(1,j,k) !            pyl(2,j,k) = pris(2,j,k) !            pyl(3,j,k) = pris(3,j,k) !            pyl(4,j,k) = pris(4,j,k) !            pyr(1,j,k) = pris(1,j,k+1) !            pyr(2,j,k) = pris(2,j,k+1) !            pyr(3,j,k) = pris(3,j,k+1) !            pyr(4,j,k) = pris(4,j,k+1) !          end do !        end do ! high(3rd) order !       x do k = 2 , kmax - 1 do j = 1 , jmax dm1 = - pris ( 1 , j - 1 , k ) + pris ( 1 , j , k ) dp1 = - pris ( 1 , j , k ) + pris ( 1 , j + 1 , k ) dm2 = - pris ( 2 , j - 1 , k ) + pris ( 2 , j , k ) dp2 = - pris ( 2 , j , k ) + pris ( 2 , j + 1 , k ) dm3 = - pris ( 3 , j - 1 , k ) + pris ( 3 , j , k ) dp3 = - pris ( 3 , j , k ) + pris ( 3 , j + 1 , k ) dm4 = - pris ( 4 , j - 1 , k ) + pris ( 4 , j , k ) dp4 = - pris ( 4 , j , k ) + pris ( 4 , j + 1 , k ) bdm1 = dsign ( 1.0d0 , dm1 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dm1 ), dsign ( b , dm1 ) * dp1 )) bdm2 = dsign ( 1.0d0 , dm2 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dm2 ), dsign ( b , dm2 ) * dp2 )) bdm3 = dsign ( 1.0d0 , dm3 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dm3 ), dsign ( b , dm3 ) * dp3 )) bdm4 = dsign ( 1.0d0 , dm4 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dm4 ), dsign ( b , dm4 ) * dp4 )) bdp1 = dsign ( 1.0d0 , dp1 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dp1 ), dsign ( b , dp1 ) * dm1 )) bdp2 = dsign ( 1.0d0 , dp2 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dp2 ), dsign ( b , dp2 ) * dm2 )) bdp3 = dsign ( 1.0d0 , dp3 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dp3 ), dsign ( b , dp3 ) * dm3 )) bdp4 = dsign ( 1.0d0 , dp4 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dp4 ), dsign ( b , dp4 ) * dm4 )) pxl ( 1 , j , k ) = pris ( 1 , j , k ) + 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdm1 + ( 1.0d0 + dkpa ) * bdp1 ) pxl ( 2 , j , k ) = pris ( 2 , j , k ) + 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdm2 + ( 1.0d0 + dkpa ) * bdp2 ) pxl ( 3 , j , k ) = pris ( 3 , j , k ) + 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdm3 + ( 1.0d0 + dkpa ) * bdp3 ) pxl ( 4 , j , k ) = pris ( 4 , j , k ) + 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdm4 + ( 1.0d0 + dkpa ) * bdp4 ) pxr ( 1 , j - 1 , k ) = pris ( 1 , j , k ) - 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdp1 + ( 1.0d0 + dkpa ) * bdm1 ) pxr ( 2 , j - 1 , k ) = pris ( 2 , j , k ) - 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdp2 + ( 1.0d0 + dkpa ) * bdm2 ) pxr ( 3 , j - 1 , k ) = pris ( 3 , j , k ) - 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdp3 + ( 1.0d0 + dkpa ) * bdm3 ) pxr ( 4 , j - 1 , k ) = pris ( 4 , j , k ) - 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdp4 + ( 1.0d0 + dkpa ) * bdm4 ) end do end do !       y do j = 2 , jmax - 1 do k = 1 , kmax dm1 = - pris ( 1 , j , k - 1 ) + pris ( 1 , j , k ) dp1 = - pris ( 1 , j , k ) + pris ( 1 , j , k + 1 ) dm2 = - pris ( 2 , j , k - 1 ) + pris ( 2 , j , k ) dp2 = - pris ( 2 , j , k ) + pris ( 2 , j , k + 1 ) dm3 = - pris ( 3 , j , k - 1 ) + pris ( 3 , j , k ) dp3 = - pris ( 3 , j , k ) + pris ( 3 , j , k + 1 ) dm4 = - pris ( 4 , j , k - 1 ) + pris ( 4 , j , k ) dp4 = - pris ( 4 , j , k ) + pris ( 4 , j , k + 1 ) bdm1 = dsign ( 1.0d0 , dm1 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dm1 ), dsign ( b , dm1 ) * dp1 )) bdm2 = dsign ( 1.0d0 , dm2 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dm2 ), dsign ( b , dm2 ) * dp2 )) bdm3 = dsign ( 1.0d0 , dm3 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dm3 ), dsign ( b , dm3 ) * dp3 )) bdm4 = dsign ( 1.0d0 , dm4 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dm4 ), dsign ( b , dm4 ) * dp4 )) bdp1 = dsign ( 1.0d0 , dp1 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dp1 ), dsign ( b , dp1 ) * dm1 )) bdp2 = dsign ( 1.0d0 , dp2 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dp2 ), dsign ( b , dp2 ) * dm2 )) bdp3 = dsign ( 1.0d0 , dp3 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dp3 ), dsign ( b , dp3 ) * dm3 )) bdp4 = dsign ( 1.0d0 , dp4 ) * dmax1 ( 0.0d0 , & dmin1 ( dabs ( dp4 ), dsign ( b , dp4 ) * dm4 )) pyl ( 1 , j , k ) = pris ( 1 , j , k ) + 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdm1 + ( 1.0d0 + dkpa ) * bdp1 ) pyl ( 2 , j , k ) = pris ( 2 , j , k ) + 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdm2 + ( 1.0d0 + dkpa ) * bdp2 ) pyl ( 3 , j , k ) = pris ( 3 , j , k ) + 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdm3 + ( 1.0d0 + dkpa ) * bdp3 ) pyl ( 4 , j , k ) = pris ( 4 , j , k ) + 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdm4 + ( 1.0d0 + dkpa ) * bdp4 ) pyr ( 1 , j , k - 1 ) = pris ( 1 , j , k ) - 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdp1 + ( 1.0d0 + dkpa ) * bdm1 ) pyr ( 2 , j , k - 1 ) = pris ( 2 , j , k ) - 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdp2 + ( 1.0d0 + dkpa ) * bdm2 ) pyr ( 3 , j , k - 1 ) = pris ( 3 , j , k ) - 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdp3 + ( 1.0d0 + dkpa ) * bdm3 ) pyr ( 4 , j , k - 1 ) = pris ( 4 , j , k ) - 0.25d0 * eps * & (( 1.0d0 - dkpa ) * bdp4 + ( 1.0d0 + dkpa ) * bdm4 ) end do end do end subroutine intp subroutine slau implicit double precision ( a - h , o - z ) common / sflr / conL ( 4 ), conR ( 4 ), dnflx ( 4 ) common / nvec / dnx , dny parameter ( gmma = 1.4d0 , gmm1 = gmma - 1.0d0 , gm1i = 1.0d0 / gmm1 ) !  Left state rl = conL ( 1 ) ul = conL ( 2 ) / conL ( 1 ) vl = conL ( 3 ) / conL ( 1 ) pl = gmm1 * ( conL ( 4 ) - 0.5d0 * rL * ( uL * uL + vL * vL ) ) al = dsqrt ( gmma * pL / rL ) dhl = ( conL ( 4 ) + pL ) / rL vnp = ul * dnx + vl * dny !  Right state rr = conR ( 1 ) ur = conR ( 2 ) / conR ( 1 ) vr = conR ( 3 ) / conR ( 1 ) pr = gmm1 * ( conR ( 4 ) - 0.5d0 * rR * ( uR * uR + vR * vR ) ) ar = dsqrt ( gmma * pR / rR ) dhr = ( conR ( 4 ) + pR ) / rR vnm = ur * dnx + vr * dny cbar = 0.5d0 * ( al + ar ) cbi = 1.0d0 / cbar dmp = vnp * cbi dmm = vnm * cbi g = - dmax1 ( dmin1 ( dmp , 0.0d0 ), - 1.0d0 ) * & dmin1 ( dmax1 ( dmm , 0.0d0 ), 1.0d0 ) dmht = dmin1 ( 1.0d0 , cbi * dsqrt ( 0.5d0 * ( ul * ul + vl * vl + ur * ur + vr * vr ))) xi = ( 1.0d0 - dmht ) * ( 1.0d0 - dmht ) absbv = ( rl * dabs ( vnp ) + rr * dabs ( vnm )) / ( rl + rr ) dmdt = 0.5d0 * ( rl * vnp + rr * vnm - absbv * ( rr - rl )) * ( 1.0d0 - g ) & - xi * 0.5d0 * cbi * ( pr - pl ) admd = dabs ( dmdt ) if ( dabs ( dmp ) < 1.0d0 ) then bp = 0.25d0 * ( 2.0d0 - dmp ) * ( dmp + 1.0d0 ) * ( dmp + 1.0d0 ) else bp = 0.5d0 * ( 1.0d0 + dsign ( 1.0d0 , dmp )) end if if ( dabs ( dmm ) < 1.0d0 ) then bm = 0.25d0 * ( 2.0d0 + dmm ) * ( dmm - 1.0d0 ) * ( dmm - 1.0d0 ) else bm = 0.5d0 * ( 1.0d0 + dsign ( 1.0d0 , - dmm )) end if ptld = 0.5d0 * ( ( pl + pr ) + ( bp - bm ) * ( pl - pr ) & + ( 1.0d0 - xi ) * ( bp + bm - 1.0d0 ) * ( pl + pr )) dm1 = dmdt + admd dm2 = dmdt - admd dnflx ( 1 ) = dmdt dnflx ( 2 ) = 0.5d0 * ( dm1 * ul + dm2 * ur ) + ptld * dnx dnflx ( 3 ) = 0.5d0 * ( dm1 * vl + dm2 * vr ) + ptld * dny dnflx ( 4 ) = 0.5d0 * ( dm1 * dhl + dm2 * dhr ) end subroutine slau subroutine iflx include \"parameters.f\" common / sval / pxl ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), pxr ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), & pyl ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ), pyr ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) common / flux / xflx ( 4 , jmax , kmax ), yflx ( 4 , jmax , kmax ) !        double precision conl(4),conr(4),dnflx(4) common / sflr / conL ( 4 ), conR ( 4 ), dnflx ( 4 ) common / nvec / dnx , dny one = 1.0d0 zero = 0.0d0 !       x flux dnx = 1.0d0 dny = 0.0d0 do k = 2 , kmax - 1 do j = 1 , jmax - 1 !           left state rl = pxl ( 1 , j , k ) ul = pxl ( 2 , j , k ) vl = pxl ( 3 , j , k ) pl = pxl ( 4 , j , k ) conl ( 1 ) = rl conl ( 2 ) = rl * ul conl ( 3 ) = rl * vl conl ( 4 ) = gm1i * pl + 0.5d0 * rl * ( ul * ul + vl * vl ) !           right state rr = pxr ( 1 , j , k ) ur = pxr ( 2 , j , k ) vr = pxr ( 3 , j , k ) pr = pxr ( 4 , j , k ) conr ( 1 ) = rr conr ( 2 ) = rr * ur conr ( 3 ) = rr * vr conr ( 4 ) = gm1i * pr + 0.5d0 * rr * ( ur * ur + vr * vr ) call slau xflx ( 1 , j , k ) = dnflx ( 1 ) xflx ( 2 , j , k ) = dnflx ( 2 ) xflx ( 3 , j , k ) = dnflx ( 3 ) xflx ( 4 , j , k ) = dnflx ( 4 ) end do end do !       y flux dnx = 0.0d0 dny = 1.0d0 do j = 2 , jmax - 1 do k = 1 , kmax - 1 !           left state rl = pyl ( 1 , j , k ) ul = pyl ( 2 , j , k ) vl = pyl ( 3 , j , k ) pl = pyl ( 4 , j , k ) conl ( 1 ) = rl conl ( 2 ) = rl * ul conl ( 3 ) = rl * vl conl ( 4 ) = gm1i * pl + 0.5d0 * rl * ( ul * ul + vl * vl ) !           right state rr = pyr ( 1 , j , k ) ur = pyr ( 2 , j , k ) vr = pyr ( 3 , j , k ) pr = pyr ( 4 , j , k ) conr ( 1 ) = rr conr ( 2 ) = rr * ur conr ( 3 ) = rr * vr conr ( 4 ) = gm1i * pr + 0.5d0 * rr * ( ur * ur + vr * vr ) call slau yflx ( 1 , j , k ) = dnflx ( 1 ) yflx ( 2 , j , k ) = dnflx ( 2 ) yflx ( 3 , j , k ) = dnflx ( 3 ) yflx ( 4 , j , k ) = dnflx ( 4 ) end do end do !stop end subroutine iflx subroutine intg include \"parameters.f\" common / flux / xflx ( 4 , jmax , kmax ), yflx ( 4 , jmax , kmax ) common / cons / cons ( 4 , 0 : jmax + 1 , 0 : kmax + 1 ) common / dflx / df ( 4 , jmax , kmax ) common / dlxy / dltx , dlty do k = 2 , kmax - 1 do j = 2 , jmax - 1 df ( 1 , j , k ) = ( - xflx ( 1 , j - 1 , k ) + xflx ( 1 , j , k )) / dltx df ( 2 , j , k ) = ( - xflx ( 2 , j - 1 , k ) + xflx ( 2 , j , k )) / dltx df ( 3 , j , k ) = ( - xflx ( 3 , j - 1 , k ) + xflx ( 3 , j , k )) / dltx df ( 4 , j , k ) = ( - xflx ( 4 , j - 1 , k ) + xflx ( 4 , j , k )) / dltx df ( 1 , j , k ) = df ( 1 , j , k ) + ( - yflx ( 1 , j , k - 1 ) + yflx ( 1 , j , k )) / dlty df ( 2 , j , k ) = df ( 2 , j , k ) + ( - yflx ( 2 , j , k - 1 ) + yflx ( 2 , j , k )) / dlty df ( 3 , j , k ) = df ( 3 , j , k ) + ( - yflx ( 3 , j , k - 1 ) + yflx ( 3 , j , k )) / dlty df ( 4 , j , k ) = df ( 4 , j , k ) + ( - yflx ( 4 , j , k - 1 ) + yflx ( 4 , j , k )) / dlty end do end do end subroutine intg","tags":"","loc":"sourcefile/main.f.html"},{"title":"parameters.f – double mach reflection problem","text":"x方向格子点数\ny方向格子点数\n時間刻み幅\n比熱比と関連定数\n定数（計算速度性能に寄与するかはよくわからない） Contents Source Code parameters.f Source Code implicit double precision ( a - h , o - z ) !> x方向格子点数 parameter ( jmax = 1001 ) !> y方向格子点数 parameter ( kmax = 251 ) !> 時間刻み幅 parameter ( dt = 5.0d-5 ) !> 比熱比と関連定数 parameter ( gmma = 1.4d0 , gmm1 = gmma - 1.0d0 , gm1i = 1.0d0 / gmm1 ) !> 定数（計算速度性能に寄与するかはよくわからない） parameter ( onethird = 1.0d0 / 3.0d0 )","tags":"","loc":"sourcefile/parameters.f.html"}]}